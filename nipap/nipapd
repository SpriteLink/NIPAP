#!/usr/bin/env python
# vim: et sw=4 sts=4 :

import fcntl
import logging
import logging.handlers
import optparse
import os
import sys
import ConfigParser

from nipap.nipapconfig import NipapConfig, NipapConfigError
from nipap.backend import NipapError

def drop_privileges(uid_name='nobody', gid_name='nogroup'):
    if os.getuid() != 0:
        raise NipapError("non-root user cannot drop privileges")

    import pwd, grp
    # Get the uid/gid from the name
    uid = pwd.getpwnam(uid_name).pw_uid
    gid = grp.getgrnam(gid_name).gr_gid

    # Remove group privileges
    os.setgroups([])

    # Try setting the new uid/gid
    os.setgid(gid)
    os.setuid(uid)

    # Ensure a very conservative umask
    old_umask = os.umask(077)


if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.add_option("-d", "--debug", action="store_true", dest="debug", help="enable debugging")
    parser.add_option("-f", "--foreground", action="store_true", dest="foreground", help="run in foreground and log to stdout")
    parser.add_option("-l", "--listen", metavar="ADDRESS", help="listen to IPv4/6 ADDRESS")
    parser.add_option("-p", "--port", dest="port", type="int", help="listen on TCP port PORT")
    parser.add_option("-c", "--config", dest="config_file", type="string", default="/etc/nipap/nipap.conf", help="read configuration from file CONFIG_FILE")
    parser.add_option("-P", "--pid-file", type="string", help="write a PID file to PID_FILE")
    parser.add_option("--no-pid-file", action="store_true", default=False, help="turn off writing PID file (overrides config file)")
    parser.add_option("--version", action="store_true", help="display version information and exit")
    parser.add_option("--db-version", dest="dbversion", action="store_true", help="display database schema version information and exit")

    (options, args) = parser.parse_args()

    if options.version:
        import nipap
        print "nipapd version:", nipap.__version__
        sys.exit(0)

    # set logging format
    LOG_FORMAT = "%(asctime)s: %(module)-10s %(levelname)-8s %(message)s"
    # setup basic logging
    logging.basicConfig(format=LOG_FORMAT)
    logger = logging.getLogger()

    default = {
        'syslog': 'false',
        'debug': 'false',
        'foreground': 'false',
        'pid_file': None,
        'listen': '127.0.0.1',
        'port': '1337',
        'db_host': 'localhost',
        'db_name': 'nipap',
        'db_port': None,
        'db_user': 'nipap',
        'db_pass': 'papin',
        'db_sslmode': 'require',
        'auth_cache_timeout': '3600',
        'user': None,
        'group': None
    }

    try:
        cfg = NipapConfig(options.config_file, default)
    except NipapConfigError, exc:
        if options.config_file:
            print >> sys.stderr, "The specified configuration file ('" + options.config_file + "') does not exist"
            sys.exit(1)
        # if no config file is specified, we'll live with our defaults

    # Go through list of optparse options and set the config object to
    # their values.
    for val in parser.option_list:

        if val.dest is None:
            continue
        # This is not very pretty... but how can I otherwise access elements
        # in the options object from variables?
        try:
            if eval('options.' + val.dest) is None:
                continue
        except AttributeError:
            continue

        try:
            cfg.set('nipapd', val.dest, str(eval("options." + val.dest)))
        except ConfigParser.NoSectionError as exc:
            print >> sys.stderr, "The configuration file contains errors:", exc
            sys.exit(1)

    # drop privileges
    if cfg.get('nipapd', 'user') is not None:
        run_user = cfg.get('nipapd', 'user')
        if cfg.get('nipapd', 'group') is not None:
            run_group = cfg.get('nipapd', 'group')
        else:
            run_group = cfg.get('nipapd', 'user')
        try:
            drop_privileges(run_user, run_group)
        except NipapError:
            print >> sys.stderr, ("nipapd is configured to drop privileges and run as user '%s' and group '%s', \n"
                        "but was not started as root and can therefore not drop privileges") % (run_user, run_group)
            sys.exit(1)
        except KeyError:
            print >> sys.stderr, "Could not drop privileges to user '%s' and group '%s'" % (run_user, run_group)
            sys.exit(1)

    if options.dbversion:
        from nipap.backend import Nipap
        nip = Nipap()
        print "nipap db schema:", nip._get_db_version()
        sys.exit(0)

    # pre-start checks
    from nipap import authlib
    a = authlib.SqliteAuth('local', 'a', 'b', 'c')
    try:
        latest = a._latest_db_version()
        if not latest:
            print >> sys.stderr, "It seems your Sqlite database for local auth is out of date"
            print >> sys.stderr, "Please run 'nipap-passwd --upgrade-database' to upgrade your database."
            sys.exit(2)
    except authlib.AuthSqliteError, e:
        print >> sys.stderr, "Error checking version of Sqlite database for local auth: %s" % e
        sys.exit(1)
    del a

    #check nipap database schema version
    from nipap.backend import Nipap
    import nipap
    nip = Nipap()
    current_db_version = nip._get_db_version()
    if current_db_version != nipap.__db_version__:
        print >> sys.stderr, "NIPAP PostgreSQL database is outdated. Schema version '%s' is required to run but you are using '%s'" % (nipap.__db_version__, current_db_version)
        sys.exit(1)


    if not cfg.getboolean('nipapd', 'foreground'):
        import nipap.daemon
        ret = nipap.daemon.createDaemon()

    # pid file handling
    if cfg.get('nipapd', 'pid_file') and not options.no_pid_file:
        # need a+ to be able to read PID from file
        try:
            lf = open(cfg.get('nipapd', 'pid_file'), 'a+', 0)
        except IOError, exc:
            logger.error("Unable to open PID file '" + str(exc.filename) + "': " + str(exc.strerror))
            sys.exit(1)
        try:
            fcntl.flock(lf, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            logger.error('NIPAPd already running (pid: ' + lf.read().strip() + ')')
            sys.exit(1)
        logger.debug('Writing PID to file: ' + cfg.get('nipapd', 'pid_file'))
        lf.truncate()
        lf.write('%d\n' % os.getpid())
        lf.flush()

    import nipap.xmlrpc
    nipapxml = nipap.xmlrpc.setup()

    if not cfg.getboolean('nipapd', 'foreground'):
        # If we are not running in the foreground, remove current handlers which
        # include a default streamhandler to stdout to prevent messages on
        # stdout when in daemon mode.
        for h in logger.handlers:
            logger.removeHandler(h)

    # logging
    if cfg.getboolean('nipapd', 'debug'):
        logger.setLevel(logging.DEBUG)
        nipapxml.logger.setLevel(logging.DEBUG)

    from tornado.netutil import bind_sockets
    from tornado.httpserver import HTTPServer
    from tornado.wsgi import WSGIContainer
    import tornado.process
    from tornado.ioloop import IOLoop

    if cfg.getboolean('nipapd', 'syslog'):
        log_syslog = logging.handlers.SysLogHandler(address = '/dev/log')
        log_syslog.setFormatter(logging.Formatter("%(levelname)-8s %(message)s"))
        logger.addHandler(log_syslog)
        nipapxml.logger.addHandler(log_syslog)

    # pre-fork if we are not running in foreground
    if not cfg.get('nipapd', 'foreground'):
        # default is to fork as many processes as there are cores
        tornado.process.fork_processes(None)

    http_server = HTTPServer(WSGIContainer(nipapxml))
    if cfg.get('nipapd', 'listen') is None or cfg.get('nipapd', 'listen') == '':
        sockets = bind_sockets(cfg.get('nipapd', 'port'))
    else:
        sockets = []
        for entry in cfg.get('nipapd', 'listen').split(','):
            if len(entry.split('+')) > 1:
                address = entry.split('+')[0]
                port = int(entry.split('+')[1])
            else:
                address = entry
                port = int(cfg.get('nipapd', 'port'))
            socket = bind_sockets(port, address)
            sockets = sockets + socket

    http_server.add_sockets(sockets)

    # start Tornado
    try:
        IOLoop.instance().start()
    except KeyboardInterrupt:
        sys.exit(0)
    except Exception as exc:
        logger.error(exc)
        sys.exit(1)

